{"version":3,"file":"coinSelection-2582f135.js","sources":["../src/coinSelection.js"],"sourcesContent":["import {\n    TransactionUnspentOutput,\n    TransactionOutputs,\n    Value,\n  } from '@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib';\n  //import Loader from '../api/loader';\n\n\n\n/**\n * Copied directly from Nami wallet github repo\n * small changes to make it compatible\n *  \n */\n\n\n\n  let Loader = null\n  /**\n   * BerryPool implementation of the __Random-Improve__ coin selection algorithm.\n   *\n   * = Overview\n   *\n   * The __Random-Improve__ coin selection algorithm works in __two phases__, by\n   * /first/ selecting UTxO entries /at random/ to pay for each of the given\n   * outputs, and /then/ attempting to /improve/ upon each of the selections.\n   *\n   * === Phase 1: Random Selection\n   *\n   * __In this phase, the algorithm randomly selects a minimal set of UTxO__\n   * __entries to pay for each of the given outputs.__\n   *\n   * During this phase, the algorithm:\n   *\n   *   *  processes outputs in /descending order of coin value/.\n   *\n   *   *  maintains a /remaining UTxO set/, initially equal to the given\n   *      /UTxO set/ parameter.\n   *\n   *   *  based on every output nature, generate a /native token UTxO subset/\n   *      to narrow down to useful UTxO\n   *\n   *   *  maintains an /accumulated coin selection/, which is initially /empty/.\n   *\n   * For each output of value __/v/__, the algorithm /randomly/ selects entries\n   * from the /remaining UTxO set/, until the total value of selected entries is\n   * greater than or equal to __/v/__. The selected entries are then associated\n   * with that output, and removed from the /remaining UTxO set/.\n   *\n   * This phase ends when every output has been associated with a selection of\n   * UTxO entries.\n   *\n   * However, if the remaining UTxO set is completely exhausted before all\n   * outputs can be processed, the algorithm terminates with an error.\n   *\n   * === Phase 2: Improvement\n   *\n   * __In this phase, the algorithm attempts to improve upon each of the UTxO__\n   * __selections made in the previous phase, by conservatively expanding the__\n   * __selection made for each output.__\n   *\n   * During this phase, the algorithm:\n   *\n   *   *  processes outputs in /ascending order of coin value/.\n   *\n   *   *  continues to maintain the /remaining UTxO set/ produced by the previous\n   *      phase.\n   *\n   *   *  maintains an /accumulated coin selection/, initiated from previous phase.\n   *\n   * For each output of value __/v/__, the algorithm:\n   *\n   *  1.  __Calculates a /target range/__ for the total value of inputs used to\n   *      pay for that output, defined by the triplet:\n   *\n   *      (/minimum/, /ideal/, /maximum/) = (/v/, /2v/, /3v/)\n   *\n   *  2.  __Attempts to /improve/ upon the /existing UTxO selection/__ for that\n   *      output, by repeatedly selecting additional entries at random from the\n   *      /remaining UTxO set/, stopping when the selection can be improved upon\n   *      no further.\n   *\n   *      A selection with value /v1/ is considered to be an /improvement/ over a\n   *      selection with value /v0/ if __all__ of the following conditions are\n   *      satisfied:\n   *\n   *       * __Condition 1__: we have moved closer to the /ideal/ value:\n   *\n   *             abs (/ideal/ − /v1/) < abs (/ideal/ − /v0/)\n   *\n   *       * __Condition 2__: we have not exceeded the /maximum/ value:\n   *\n   *             /v1/ ≤ /maximum/\n   *\n   *       * __Condition 3__: when counting cumulatively across all outputs\n   *       considered so far, we have not selected more than the /maximum/ number\n   *       of UTxO entries specified by 'limit'.\n   *\n   *  3.  __Creates a /change value/__ for the output, equal to the total value\n   *      of the /final UTxO selection/ for that output minus the value /v/ of\n   *      that output.\n   *\n   *  4.  __Updates the /accumulated coin selection/__:\n   *\n   *       * Adds the /output/ to 'outputs'.\n   *       * Adds the /improved UTxO selection/ to 'inputs'.\n   *       * Adds the /change value/ to 'change'.\n   *\n   * This phase ends when every output has been processed, __or__ when the\n   * /remaining UTxO set/ has been exhausted, whichever occurs sooner.\n   *\n   * = Termination\n   *\n   * When both phases are complete, the algorithm terminates.\n   *\n   * The /accumulated coin selection/ and /remaining UTxO set/ are returned to\n   * the caller.\n   *\n   * === Failure Modes\n   *\n   * The algorithm terminates with an __error__ if:\n   *\n   *  1.  The /total value/ of the initial UTxO set (the amount of money\n   *      /available/) is /less than/ the total value of the output list (the\n   *      amount of money /required/).\n   *\n   *      See: __'InputsExhaustedError'__.\n   *\n   *  2.  The /number/ of UTxO entries needed to pay for the requested outputs\n   *      would /exceed/ the upper limit specified by 'limit'.\n   *\n   *      See: __'InputLimitExceededError'__.\n   *\n   * == Motivating Principles\n   *\n   * There are several motivating principles behind the design of the algorithm.\n   *\n   * === Principle 1: Dust Management\n   *\n   * The probability that random selection will choose dust entries from a UTxO\n   * set increases with the proportion of dust in the set.\n   *\n   * Therefore, for a UTxO set with a large amount of dust, there's a high\n   * probability that a random subset will include a large amount of dust.\n   *\n   * === Principle 2: Change Management\n   *\n   * Ideally, coin selection algorithms should, over time, create a UTxO set that\n   * has /useful/ outputs: outputs that will allow us to process future payments\n   * with a minimum number of inputs.\n   *\n   * If for each payment request of value __/v/__ we create a change output of\n   * /roughly/ the same value __/v/__, then we will end up with a distribution of\n   * change values that matches the typical value distribution of payment\n   * requests.\n   *\n   * === Principle 3: Performance Management\n   *\n   * Searching the UTxO set for additional entries to improve our change outputs\n   * is /only/ useful if the UTxO set contains entries that are sufficiently\n   * small enough. But it is precisely when the UTxO set contains many small\n   * entries that it is less likely for a randomly-chosen UTxO entry to push the\n   * total above the upper bound.\n   */\n  \n  /**\n   * @typedef {Value[]} AmountList - List of 'Value' object\n   */\n  \n  /**\n   * @typedef {TransactionUnspentOutput[]} UTxOList - List of UTxO\n   */\n  \n  /**\n   * @typedef {Object} UTxOSelection - Coin Selection algorithm core object\n   * @property {UTxOList} selection - Accumulated UTxO set.\n   * @property {UTxOList} remaining - Remaining UTxO set.\n   * @property {UTxOList} subset - Remaining UTxO set.\n   * @property {Value} amount - UTxO amount of each requested token\n   */\n  \n  /**\n   * @typedef {Object} ImproveRange - ImproveRange\n   * @property {Value} ideal - Requested amount * 2\n   * @property {Value} maximum - Requested amount * 3\n   */\n  \n  /**\n   * @typedef {Object} SelectionResult - Coin Selection algorithm return\n   * @property {UTxOList} input - Accumulated UTxO set.\n   * @property {OutputList} output - Requested outputs.\n   * @property {UTxOList} remaining - Remaining UTxO set.\n   * @property {Value} amount - UTxO amount of each requested token\n   * @property {Value} change - Accumulated change amount.\n   */\n  \n  /**\n   * @typedef {Object} ProtocolParameters\n   * @property {int} minUTxO\n   * @property {int} minFeeA\n   * @property {int} minFeeB\n   * @property {int} maxTxSize\n   */\n  \n  /**\n   * @type {ProtocolParameters}\n   */\n  let protocolParameters = null;\n  \n  /**\n   * CoinSelection Module.\n   * @module src/lib/CoinSelection\n   */\n  const CoinSelection = {\n    /**\n     * Set protocol parameters required by the algorithm\n     * @param {string} minUTxO\n     * @param {string} minFeeA\n     * @param {string} minFeeB\n     * @param {string} maxTxSize\n     */\n\n    setLoader: (lib) => {\n      Loader = {\n        Cardano: lib\n      }\n    },\n\n    setProtocolParameters: (minUTxO, minFeeA, minFeeB, maxTxSize) => {\n      protocolParameters = {\n        minUTxO: minUTxO,\n        minFeeA: minFeeA,\n        minFeeB: minFeeB,\n        maxTxSize: maxTxSize,\n      };\n    },\n    /**\n     * Random-Improve coin selection algorithm\n     * @param {UTxOList} inputs - The set of inputs available for selection.\n     * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\n     * @param {int} limit - A limit on the number of inputs that can be selected.\n     * @return {SelectionResult} - Coin Selection algorithm return\n     */\n    randomImprove: (inputs, outputs, limit) => {\n      if (!protocolParameters)\n        throw new Error(\n          'Protocol parameters not set. Use setProtocolParameters().'\n        );\n  \n      //await Loader.load();\n  \n      const _minUTxOValue =\n        BigInt(outputs.len()) * BigInt(protocolParameters.minUTxO);\n  \n      /** @type {UTxOSelection} */\n      let utxoSelection = {\n        selection: [],\n        remaining: [...inputs], // Shallow copy\n        subset: [],\n        amount: Loader.Cardano.Value.new(Loader.Cardano.BigNum.from_str('0')),\n      };\n  \n      let mergedOutputsAmounts = mergeOutputsAmounts(outputs);\n  \n      // Explode amount in an array of unique asset amount for comparison's sake\n      let splitOutputsAmounts = splitAmounts(mergedOutputsAmounts);\n  \n      // Phase 1: Select enough input\n      for (let i = 0; i < splitOutputsAmounts.length; i++) {\n        createSubSet(utxoSelection, splitOutputsAmounts[i]); // Narrow down for NatToken UTxO\n  \n        utxoSelection = select(\n          utxoSelection,\n          splitOutputsAmounts[i],\n          limit,\n          _minUTxOValue\n        );\n      }\n  \n      // Phase 2: Improve\n      splitOutputsAmounts = sortAmountList(splitOutputsAmounts);\n  \n      for (let i = 0; i < splitOutputsAmounts.length; i++) {\n        createSubSet(utxoSelection, splitOutputsAmounts[i]); // Narrow down for NatToken UTxO\n  \n        let range = {};\n        range.ideal = Loader.Cardano.Value.new(\n          Loader.Cardano.BigNum.from_str('0')\n        )\n          .checked_add(splitOutputsAmounts[i])\n          .checked_add(splitOutputsAmounts[i]);\n        range.maximum = Loader.Cardano.Value.new(\n          Loader.Cardano.BigNum.from_str('0')\n        )\n          .checked_add(range.ideal)\n          .checked_add(splitOutputsAmounts[i]);\n  \n        improve(\n          utxoSelection,\n          splitOutputsAmounts[i],\n          limit - utxoSelection.selection.length,\n          range\n        );\n      }\n  \n      // Insure change hold enough Ada to cover included native assets and fees\n      const change = utxoSelection.amount.checked_sub(mergedOutputsAmounts);\n  \n      let minAmount = Loader.Cardano.Value.new(\n        Loader.Cardano.min_ada_required(\n          change,\n          Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)\n        )\n      );\n  \n      let maxFee =\n        BigInt(protocolParameters.minFeeA) *\n          BigInt(protocolParameters.maxTxSize) +\n        BigInt(protocolParameters.minFeeB);\n  \n      maxFee = Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_str(maxFee.toString())\n      );\n  \n      minAmount = minAmount.checked_add(maxFee);\n  \n      if (compare(change, minAmount) < 0) {\n        // Not enough, add missing amount and run select one last time\n        const minAda = minAmount\n          .checked_sub(Loader.Cardano.Value.new(change.coin()))\n          .checked_add(Loader.Cardano.Value.new(utxoSelection.amount.coin()));\n  \n        createSubSet(utxoSelection, minAda);\n        utxoSelection = select(utxoSelection, minAda, limit, _minUTxOValue);\n      }\n  \n      return {\n        input: utxoSelection.selection,\n        output: outputs,\n        remaining: utxoSelection.remaining,\n        amount: utxoSelection.amount,\n        change: utxoSelection.amount.checked_sub(mergedOutputsAmounts),\n      };\n    },\n  };\n  \n  /**\n   * Use randomSelect & descSelect algorithm to select enough UTxO to fulfill requested outputs\n   * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n   * @param {Value} outputAmount - Single compiled output qty requested for payment.\n   * @param {int} limit - A limit on the number of inputs that can be selected.\n   * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n   * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n   * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n   * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n   * @return {UTxOSelection} - Successful random utxo selection.\n   */\n  function select(utxoSelection, outputAmount, limit, minUTxOValue) {\n    try {\n      utxoSelection = randomSelect(\n        cloneUTxOSelection(utxoSelection), // Deep copy in case of fallback needed\n        outputAmount,\n        limit - utxoSelection.selection.length,\n        minUTxOValue\n      );\n    } catch (e) {\n      if (e.message === 'INPUT_LIMIT_EXCEEDED') {\n        // Limit reached : Fallback on DescOrdAlgo\n        utxoSelection = descSelect(\n          utxoSelection,\n          outputAmount,\n          limit - utxoSelection.selection.length,\n          minUTxOValue\n        );\n      } else {\n        throw e;\n      }\n    }\n  \n    return utxoSelection;\n  }\n  \n  /**\n   * Randomly select enough UTxO to fulfill requested outputs\n   * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n   * @param {Value} outputAmount - Single compiled output qty requested for payment.\n   * @param {int} limit - A limit on the number of inputs that can be selected.\n   * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n   * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n   * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n   * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n   * @return {UTxOSelection} - Successful random utxo selection.\n   */\n  function randomSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n    let nbFreeUTxO = utxoSelection.subset.length;\n    // If quantity is met, return subset into remaining list and exit\n    if (\n      isQtyFulfilled(outputAmount, utxoSelection.amount, minUTxOValue, nbFreeUTxO)\n    ) {\n      utxoSelection.remaining = [\n        ...utxoSelection.remaining,\n        ...utxoSelection.subset,\n      ];\n      utxoSelection.subset = [];\n      return utxoSelection;\n    }\n  \n    if (limit <= 0) {\n      throw new Error('INPUT_LIMIT_EXCEEDED');\n    }\n  \n    if (nbFreeUTxO <= 0) {\n      if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n        throw new Error('MIN_UTXO_ERROR');\n      }\n      throw new Error('INPUTS_EXHAUSTED');\n    }\n  \n    /** @type {TransactionUnspentOutput} utxo */\n    let utxo = utxoSelection.subset\n      .splice(Math.floor(Math.random() * nbFreeUTxO), 1)\n      .pop();\n  \n    utxoSelection.selection.push(utxo);\n    utxoSelection.amount = addAmounts(\n      utxo.output().amount(),\n      utxoSelection.amount\n    );\n  \n    return randomSelect(utxoSelection, outputAmount, limit - 1, minUTxOValue);\n  }\n  \n  /**\n   * Select enough UTxO in DESC order to fulfill requested outputs\n   * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n   * @param {Value} outputAmount - Single compiled output qty requested for payment.\n   * @param {int} limit - A limit on the number of inputs that can be selected.\n   * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n   * @throws INPUT_LIMIT_EXCEEDED if the number of randomly picked inputs exceed 'limit' parameter.\n   * @throws INPUTS_EXHAUSTED if all UTxO doesn't hold enough funds to pay for output.\n   * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n   * @return {UTxOSelection} - Successful random utxo selection.\n   */\n  function descSelect(utxoSelection, outputAmount, limit, minUTxOValue) {\n    // Sort UTxO subset in DESC order for required Output unit type\n    utxoSelection.subset = utxoSelection.subset.sort((a, b) => {\n      return Number(\n        searchAmountValue(outputAmount, b.output().amount()) -\n          searchAmountValue(outputAmount, a.output().amount())\n      );\n    });\n  \n    do {\n      if (limit <= 0) {\n        throw new Error('INPUT_LIMIT_EXCEEDED');\n      }\n  \n      if (utxoSelection.subset.length <= 0) {\n        if (isQtyFulfilled(outputAmount, utxoSelection.amount, 0, 0)) {\n          throw new Error('MIN_UTXO_ERROR');\n        }\n        throw new Error('INPUTS_EXHAUSTED');\n      }\n  \n      /** @type {TransactionUnspentOutput} utxo */\n      let utxo = utxoSelection.subset.splice(0, 1).pop();\n  \n      utxoSelection.selection.push(utxo);\n      utxoSelection.amount = addAmounts(\n        utxo.output().amount(),\n        utxoSelection.amount\n      );\n  \n      limit--;\n    } while (\n      !isQtyFulfilled(\n        outputAmount,\n        utxoSelection.amount,\n        minUTxOValue,\n        utxoSelection.subset.length - 1\n      )\n    );\n  \n    // Quantity is met, return subset into remaining list and return selection\n    utxoSelection.remaining = [\n      ...utxoSelection.remaining,\n      ...utxoSelection.subset,\n    ];\n    utxoSelection.subset = [];\n  \n    return utxoSelection;\n  }\n  \n  /**\n   * Try to improve selection by increasing input amount in [2x,3x] range.\n   * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n   * @param {Value} outputAmount - Single compiled output qty requested for payment.\n   * @param {int} limit - A limit on the number of inputs that can be selected.\n   * @param {ImproveRange} range - Improvement range target values\n   */\n  function improve(utxoSelection, outputAmount, limit, range) {\n    let nbFreeUTxO = utxoSelection.subset.length;\n  \n    if (\n      compare(utxoSelection.amount, range.ideal) >= 0 ||\n      nbFreeUTxO <= 0 ||\n      limit <= 0\n    ) {\n      // Return subset in remaining\n      utxoSelection.remaining = [\n        ...utxoSelection.remaining,\n        ...utxoSelection.subset,\n      ];\n      utxoSelection.subset = [];\n  \n      return;\n    }\n  \n    /** @type {TransactionUnspentOutput} utxo */\n    const utxo = utxoSelection.subset\n      .splice(Math.floor(Math.random() * nbFreeUTxO), 1)\n      .pop();\n  \n    const newAmount = Loader.Cardano.Value.new(\n      Loader.Cardano.BigNum.from_str('0')\n    )\n      .checked_add(utxo.output().amount())\n      .checked_add(outputAmount);\n  \n    if (\n      abs(getAmountValue(range.ideal) - getAmountValue(newAmount)) <\n        abs(getAmountValue(range.ideal) - getAmountValue(outputAmount)) &&\n      compare(newAmount, range.maximum) <= 0\n    ) {\n      utxoSelection.selection.push(utxo);\n      utxoSelection.amount = addAmounts(\n        utxo.output().amount(),\n        utxoSelection.amount\n      );\n      limit--;\n    } else {\n      utxoSelection.remaining.push(utxo);\n    }\n  \n    return improve(utxoSelection, outputAmount, limit, range);\n  }\n  \n  /**\n   * Compile all required outputs to a flat amounts list\n   * @param {TransactionOutputs} outputs - The set of outputs requested for payment.\n   * @return {Value} - The compiled set of amounts requested for payment.\n   */\n  function mergeOutputsAmounts(outputs) {\n    let compiledAmountList = Loader.Cardano.Value.new(\n      Loader.Cardano.BigNum.from_str('0')\n    );\n  \n    for (let i = 0; i < outputs.len(); i++) {\n      compiledAmountList = addAmounts(\n        outputs.get(i).amount(),\n        compiledAmountList\n      );\n    }\n  \n    return compiledAmountList;\n  }\n  \n  /**\n   * Add up an Amounts List values to another Amounts List\n   * @param {Value} amounts - Set of amounts to be added.\n   * @param {Value} compiledAmounts - The compiled set of amounts.\n   * @return {Value}\n   */\n  function addAmounts(amounts, compiledAmounts) {\n    return compiledAmounts.checked_add(amounts);\n  }\n  \n  /**\n   * Split amounts contained in a single {Value} object in separate {Value} objects\n   * @param {Value} amounts - Set of amounts to be split.\n   * @throws MIN_UTXO_ERROR if lovelace change is under 'minUTxOValue' parameter.\n   * @return {AmountList}\n   */\n  function splitAmounts(amounts) {\n    let splitAmounts = [];\n  \n    if (amounts.multiasset()) {\n      let mA = amounts.multiasset();\n  \n      for (let i = 0; i < mA.keys().len(); i++) {\n        let scriptHash = mA.keys().get(i);\n  \n        for (let j = 0; j < mA.get(scriptHash).keys().len(); j++) {\n          let _assets = Loader.Cardano.Assets.new();\n          let assetName = mA.get(scriptHash).keys().get(j);\n  \n          _assets.insert(\n            Loader.Cardano.AssetName.from_bytes(assetName.to_bytes()),\n            Loader.Cardano.BigNum.from_bytes(\n              mA.get(scriptHash).get(assetName).to_bytes()\n            )\n          );\n  \n          let _multiasset = Loader.Cardano.MultiAsset.new();\n          _multiasset.insert(\n            Loader.Cardano.ScriptHash.from_bytes(scriptHash.to_bytes()),\n            _assets\n          );\n          let _value = Loader.Cardano.Value.new(\n            Loader.Cardano.BigNum.from_str('0')\n          );\n          _value.set_multiasset(_multiasset);\n  \n          splitAmounts.push(_value);\n        }\n      }\n    }\n  \n    // Order assets by qty DESC\n    splitAmounts = sortAmountList(splitAmounts, 'DESC');\n  \n    // Insure lovelace is last to account for min ada requirement\n    splitAmounts.push(\n      Loader.Cardano.Value.new(\n        Loader.Cardano.BigNum.from_bytes(amounts.coin().to_bytes())\n      )\n    );\n  \n    return splitAmounts;\n  }\n  \n  /**\n   * Sort a mismatched AmountList ASC/DESC\n   * @param {AmountList} amountList - Set of mismatched amounts to be sorted.\n   * @param {string} [sortOrder=ASC] - Order\n   * @return {AmountList} - The sorted AmountList\n   */\n  function sortAmountList(amountList, sortOrder = 'ASC') {\n    return amountList.sort((a, b) => {\n      let sortInt = sortOrder === 'DESC' ? BigInt(-1) : BigInt(1);\n      return Number((getAmountValue(a) - getAmountValue(b)) * sortInt);\n    });\n  }\n  \n  /**\n   * Return BigInt amount value\n   * @param {Value} amount\n   * @return {bigint}\n   */\n  function getAmountValue(amount) {\n    let val = BigInt(0);\n    let lovelace = BigInt(amount.coin().to_str());\n  \n    if (lovelace > 0) {\n      val = lovelace;\n    } else if (amount.multiasset() && amount.multiasset().len() > 0) {\n      let scriptHash = amount.multiasset().keys().get(0);\n      let assetName = amount.multiasset().get(scriptHash).keys().get(0);\n      val = BigInt(amount.multiasset().get(scriptHash).get(assetName).to_str());\n    }\n  \n    return val;\n  }\n  \n  /**\n   * Search & Return BigInt amount value\n   * @param {Value} needle\n   * @param {Value} haystack\n   * @return {bigint}\n   */\n  function searchAmountValue(needle, haystack) {\n    let val = BigInt(0);\n    let lovelace = BigInt(needle.coin().to_str());\n  \n    if (lovelace > 0) {\n      val = BigInt(haystack.coin().to_str());\n    } else if (\n      needle.multiasset() &&\n      haystack.multiasset() &&\n      needle.multiasset().len() > 0 &&\n      haystack.multiasset().len() > 0\n    ) {\n      let scriptHash = needle.multiasset().keys().get(0);\n      let assetName = needle.multiasset().get(scriptHash).keys().get(0);\n      val = BigInt(haystack.multiasset().get(scriptHash).get(assetName).to_str());\n    }\n  \n    return val;\n  }\n  \n  /**\n   * Narrow down remaining UTxO set in case of native token, use full set for lovelace\n   * @param {UTxOSelection} utxoSelection - The set of selected/available inputs.\n   * @param {Value} output - Single compiled output qty requested for payment.\n   */\n  function createSubSet(utxoSelection, output) {\n    if (BigInt(output.coin().to_str()) < BigInt(1)) {\n      let subset = [];\n      let remaining = [];\n      for (let i = 0; i < utxoSelection.remaining.length; i++) {\n        if (\n          compare(utxoSelection.remaining[i].output().amount(), output) !==\n          undefined\n        ) {\n          subset.push(utxoSelection.remaining[i]);\n        } else {\n          remaining.push(utxoSelection.remaining[i]);\n        }\n      }\n      utxoSelection.subset = subset;\n      utxoSelection.remaining = remaining;\n    } else {\n      utxoSelection.subset = utxoSelection.remaining.splice(\n        0,\n        utxoSelection.remaining.length\n      );\n    }\n  }\n  \n  /**\n   * Is Quantity Fulfilled Condition - Handle 'minUTxOValue' protocol parameter.\n   * @param {Value} outputAmount - Single compiled output qty requested for payment.\n   * @param {Value} cumulatedAmount - Single compiled accumulated UTxO qty.\n   * @param {int} minUTxOValue - Network protocol 'minUTxOValue' current value.\n   * @param {int} nbFreeUTxO - Number of free UTxO available.\n   * @return {boolean}\n   */\n  function isQtyFulfilled(\n    outputAmount,\n    cumulatedAmount,\n    minUTxOValue,\n    nbFreeUTxO\n  ) {\n    let amount = outputAmount;\n  \n    if (minUTxOValue && BigInt(outputAmount.coin().to_str()) > 0) {\n      let minAmount = Loader.Cardano.Value.new(\n        Loader.Cardano.min_ada_required(\n          cumulatedAmount,\n          Loader.Cardano.BigNum.from_str(minUTxOValue.toString())\n        )\n      );\n  \n      // Lovelace min amount to cover assets and number of output need to be met\n      if (compare(cumulatedAmount, minAmount) < 0) return false;\n  \n      // If requested Lovelace lower than minAmount, plan for change\n      if (compare(outputAmount, minAmount) < 0) {\n        amount = minAmount.checked_add(\n          Loader.Cardano.Value.new(\n            Loader.Cardano.BigNum.from_str(protocolParameters.minUTxO)\n          )\n        );\n      }\n  \n      // Try covering the max fees\n      if (nbFreeUTxO > 0) {\n        let maxFee =\n          BigInt(protocolParameters.minFeeA) *\n            BigInt(protocolParameters.maxTxSize) +\n          BigInt(protocolParameters.minFeeB);\n  \n        maxFee = Loader.Cardano.Value.new(\n          Loader.Cardano.BigNum.from_str(maxFee.toString())\n        );\n  \n        amount = amount.checked_add(maxFee);\n      }\n    }\n  \n    return compare(cumulatedAmount, amount) >= 0;\n  }\n  \n  /**\n   * Return a deep copy of UTxOSelection\n   * @param {UTxOSelection} utxoSelection\n   * @return {UTxOSelection} Clone - Deep copy\n   */\n  function cloneUTxOSelection(utxoSelection) {\n    return {\n      selection: cloneUTxOList(utxoSelection.selection),\n      remaining: cloneUTxOList(utxoSelection.remaining),\n      subset: cloneUTxOList(utxoSelection.subset),\n      amount: cloneValue(utxoSelection.amount),\n    };\n  }\n  \n  /**\n   * Return a deep copy of an UTxO List\n   * @param {UTxOList} utxoList\n   * @return {UTxOList} Cone - Deep copy\n   */\n  const cloneUTxOList = (utxoList) =>\n    utxoList.map((utxo) =>\n      Loader.Cardano.TransactionUnspentOutput.from_bytes(utxo.to_bytes())\n    );\n  \n  /**\n   * Return a deep copy of a Value object\n   * @param {Value} value\n   * @return {Value} Cone - Deep copy\n   */\n  const cloneValue = (value) => Loader.Cardano.Value.from_bytes(value.to_bytes());\n  \n  // Helper\n  function abs(big) {\n    return big < 0 ? big * BigInt(-1) : big;\n  }\n  \n  /**\n   * Compare a candidate value to the one in a group if present\n   * @param {Value} group\n   * @param {Value} candidate\n   * @return {int} - -1 group lower, 0 equal, 1 group higher, undefined if no match\n   */\n  function compare(group, candidate) {\n    let gQty = BigInt(group.coin().to_str());\n    let cQty = BigInt(candidate.coin().to_str());\n  \n    if (candidate.multiasset()) {\n      let cScriptHash = candidate.multiasset().keys().get(0);\n      let cAssetName = candidate.multiasset().get(cScriptHash).keys().get(0);\n  \n      if (group.multiasset() && group.multiasset().len()) {\n        if (\n          group.multiasset().get(cScriptHash) &&\n          group.multiasset().get(cScriptHash).get(cAssetName)\n        ) {\n          gQty = BigInt(\n            group.multiasset().get(cScriptHash).get(cAssetName).to_str()\n          );\n          cQty = BigInt(\n            candidate.multiasset().get(cScriptHash).get(cAssetName).to_str()\n          );\n        } else {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    }\n  \n    return gQty >= cQty ? (gQty === cQty ? 0 : 1) : -1;\n  }\n  \n  export default CoinSelection;"],"names":[],"mappings":"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"}